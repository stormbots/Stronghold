// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc2811.Stronghold2016.subsystems;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;

import org.usfirst.frc2811.Stronghold2016.VisionTarget;

import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.networktables.NetworkTable;

public class Vision extends Subsystem {
	
	/**
	 * NetworkTables handle to the NetworkTable GRIP will push values to
	 */
	private NetworkTable grip;
	
	/**
	 * Handle to the GRIP process
	 */
	Process gripProcess;
	
	/**
	 * Name of the NetworkTable that GRIP will push values to
	 */
	private String tableName;
	
	/**
	 * Default/fallback/failure value for multi-number NetworkTables data types
	 */
	private double[] defaultValue = new double[0];
	
	/**
	 * Default/fallback/failure value for single number NetworkTables data types
	 */
	//private double defaultSingleValue = 0;
	
	/**
	 * Error message to display if the GRIP NetworkTable does not exist or cannot be connected to
	 */
	private String unconnectedError = "VISION: Error -> NT not connected!";
	
	
	/**
	 * Height of camera off the ground
	 */
	private double cameraHeight = 0;
	
	/**
	 * Distance left or right from the shooter to the camera
	 * Camera right of shooter: Positive value
	 * Camera left of shooter: Negative value 
	 */
	private double cameraOffsetDistanceX = 0;
	
	/**
	 * Distance forward or backward from the shooter to the camera
	 * Camera in front of shooter: Positive value
	 * Camera behind[ shooter: Negative value
	 */
	private double cameraOffsetDistanceY = 0;
	
	/**
	 * Camera angle rel to vertical plane
	 * TODO: Get better measurement. Halfway between 35 and 45 for now.
	 */
	private double cameraOffsetAngleY = 0;
	
	/**
	 * Diagonal field of view of the camera
	 */
	private double diagonalFieldOfView = 0;
	
	/**
	 * Number of horizontal pixels provided by the camera
	 */
	private double cameraPixelsX = 0;
	
	/**
	 * Number of vertical pixels provided by the camera
	 */
	private double cameraPixelsY = 0;
	
	
	/**
	 * Initialize the Vision subsystem
	 * 
	 * @param networkTableName Network Table name for GRIP to post values to
	 * @param offsetX Left/Right offset of camera, in feet, relative to shooter. left: < 0; right > 0
	 * @param offsetY Front/back offset of camera, in feet, relative to shooter. down: < 0; up > 0
	 * @param cameraAngleOffset Angular offset of camera... how many degrees upward are we looking by default?
	 * @param diagonalFieldOfView The diagonal field of view (in degrees) of the camera used by the subsystem
	 * @param cameraPixelsX Number of horizontal pixels provided by the camera used by the subsystem
	 * @param cameraPixelsY Number of vertical pixels provided by the camera used by the subsystem
	 */
	public Vision(String networkTableName,
				  double cameraHeight, double offsetX, double offsetY, double cameraOffsetAngleY, // Physical attributes of the camera
				  double diagonalFieldOfView, int cameraPixelsX, int cameraPixelsY){ // Technical attributes of camera
		this.tableName = networkTableName;
		
		this.cameraHeight = cameraHeight;
		this.cameraOffsetDistanceX = offsetX;
		this.cameraOffsetDistanceY = offsetY;
		this.cameraOffsetAngleY = cameraOffsetAngleY;
		
		this.diagonalFieldOfView = diagonalFieldOfView;
		this.cameraPixelsX = cameraPixelsX;
		this.cameraPixelsY = cameraPixelsY;

		//this.cameraInit();

		// These may need to be reversed?
		this.netTableInit();
		this.gripInit();
	}

	/**
	 * Initialize the tableName NetworkTable for vision values
	 */
	public void netTableInit() {
		// getTable initializes tableName when it doesn't already exist
		grip = NetworkTable.getTable(tableName);
		
		System.out.println("VISION: NT Connected: " + grip.isConnected());
	}
	
	/**
	 * Start the GRIP process
	 */
	public void gripInit() { //initializes grip on the roborio
		System.out.println("Attempting to start/restart Grip");
		
		boolean gripIsRunning = false;
		
		//Attempt to detect already running GRIP Process
		try {
			String process;
			// getRuntime: Returns the runtime object associated with the current Java application.
			// exec: Executes the specified string command in a separate process.
			Process p = Runtime.getRuntime().exec("ps -a | grep '*[p]roject.*' | awk '{print $1}'");
			BufferedReader input = new BufferedReader(new InputStreamReader(p.getInputStream()));
			while ((process = input.readLine()) != null) {
				if (process.indexOf("project.grip") != -1) {
					int grippid = Integer.parseInt(process.substring(1, process.indexOf(" ",1)));
					System.out.println("PROCESS FOUND!!!!!!!!!!! " + grippid); // <-- Print all Process here line by line
					gripIsRunning = true;
				}
			}
			input.close();
		} catch (Exception err) {
			err.printStackTrace();
		}

		if (!gripIsRunning) { 
			try {
				System.out.println("GRIP not running -- starting");
				//				 prep to execute a new java program (GRIP) from the GRIP jarfile		
				gripProcess = new ProcessBuilder("/usr/local/frc/JRE/bin/java", "-jar", "/home/lvuser/grip.jar",
						// with our GRIP project file, the parent IO stream, and finally start the process
	    				"/home/lvuser/project.grip").start();
	    		//TODO add print statement to make sure things work right
				System.out.println("Grip successfully started");
	    		
	    	} catch (IOException e) {
	    		// The GRIP jarfile is not there, our project file is not there, or something else went horribly wrong.
	    		System.out.println("Exception! Grip could not be started");
	    		e.printStackTrace();
	    	}
		
		}
	}
	
	/**
	 * Kill the GRIP process
	 */
	public void gripStop() {
		gripProcess.destroyForcibly();
	}
	
	
	/**
	 * @return If the handle to GRIP's NetworkTable is valid and functioning
	 */
	private boolean tableConnected() {
		if(grip.isConnected()) {
			return true;
		}
		return false;
	}
	
	/**
	 * @param tableKey The key on the GRIP NetworkTable to get values from
	 * @return Values in tableKey on the GRIP NetworkTable
	 */
	private double[] getValArray(String tableKey){ //can be used to get number array values such as area
		if (this.tableConnected()) {
			return grip.getNumberArray(tableKey, defaultValue);
		} else {
			System.out.println(unconnectedError);
			return defaultValue;
		}
	}
	
	/*
	 * Get Y part of coordinate
	 * @return double the Y coord
	 */
	public double getTargetCoordY() {
		VisionTarget t = this.getBestTarget();
		
		if (t == null) {
			System.out.println("ERR: Null target. Returning -9999.");
			return -9999;
		}
		
		return t.getMappedY();
	}
	
	/**
	 * Returns the X part of the target coordinate, after image "rotation"
	 * @return the X part of the target center coordinate after image "rotation"
	 */
	public double getTargetCoordX() {
		VisionTarget t = this.getBestTarget();
		
		if (t == null) {
			System.out.println("ERR: Null target. Returning -9999.");
			return -9999;
		}
		
		return t.getMappedX();
	}
	
	/**
	 * @return Horizontal distance to target
	 */
	public double getDistanceToTarget() {
		double angleToTarget = this.getYAngleToTarget();
		
		if (angleToTarget > -9998 && angleToTarget < -10000) {
			System.out.println("NO TARGET");
			return -9999;
		}
		
		// goal center height is 8'1". Subtract the camera height to get the height difference (opp in trig)
		// this height is the distance from the ground to the middle of the target/goal
		double goalHeight = 3 + 6.5/12.0 - this.cameraHeight;
		
		/*  tan(angle) = goalHeight / distanceX
		    
		    distanceX*tan(angle) = goalHeight
		    
		    distanceX = goalHeight / tan(angle)
	    */
		double distanceX = goalHeight / Math.tan(Math.toRadians(angleToTarget));
		
		return distanceX;
	}
	/**
	 * Overload of isOnTarget(double angleTolerance). Passes default value of 3 as angleTolerance.
	 * @return Whether or not the robot/shooter is aligned with the target, +- 3 degrees.
	 */
	public boolean isOnTarget() {
		return isOnTarget(3);
	}
	
	/**
	 * @param angleTolerance Tolerance, in degrees, within which the actual angle can differ from "perfect" alignment
	 * @return Whether or not the robot/shooter is aligned with the target, +- angleTolerance degrees.
	 */
	public boolean isOnTarget(double angleTolerance) {
		VisionTarget t = this.getBestTarget();
		double expectedDegreesOffset = (t.getHeight() / 2) * this.diagonalFieldOfViewToXYFieldOfView()[1];
		
		double horizontalAngleOffset = this.getXAngleToTarget();
		
		/* Return true if the robot needs to turn less than angleTolerance degrees to be aligned
		 * with the target
		 */
		return Math.abs(horizontalAngleOffset - expectedDegreesOffset) <= angleTolerance;
	}
	
	/**
	 * Break down the diagonal field of view of the camera into horizontal FOV and vertical FOV
	 * @return an array containing {horizontal fov, vertical fov} in degrees
	 */
	private double[] diagonalFieldOfViewToXYFieldOfView(){ //this method is CLEAN
		
		// just an angle for the trig stuff... lower left acute angle for a 720p camera
		double angle = Math.toDegrees(Math.atan((double)this.cameraPixelsY/this.cameraPixelsX));
		
		// You can decompose a diagonal FOV with just basic trig
		double fovX = this.diagonalFieldOfView * Math.cos(Math.toRadians(angle));
		double fovY = this.diagonalFieldOfView * Math.sin(Math.toRadians(angle));

		double[] fovArray = {fovX, fovY};
		
		return fovArray;
	}
	
	/**
	 * Automatically returns the horizontal angle of the target (parallel to the plane of the field), based on values in the NetworkTable
	 * @return double angleHorizontal. Left - negative; Right - positive
	 */
	public double getXAngleToTarget() {
	
		VisionTarget t = this.getBestTarget();
		
		if (t == null) {
			System.out.println("NO TARGET. RETURNING -9999.");
			return -9999;
		}
		
		double objectPositionX = t.getMappedX();
		
		double[] FOVs = this.diagonalFieldOfViewToXYFieldOfView();
		
		/* Take the pixel offsets of the object from the center of the image
		 * Multiply by half of the FOV per pixel on that axis because we have FOV/2 field of view
		 * in each direction on that axis.
		 */
		double angleOffsetX = objectPositionX * (FOVs[1]/this.cameraPixelsY);

		return angleOffsetX;
	}
	
//	private double remapY(double raw) {
//		return (this.cameraPixelsX / 2) - raw;
//	}
//	
//	private double remapX(double raw) {
//		return this.cameraPixelsY / 2 - raw;
//	}
	
	public void testRemaps() {
		VisionTarget topLeft = new VisionTarget(300, 340, 100, 100, 123, .0005);
		VisionTarget topRight = new VisionTarget(800, 380, 100, 100, 124, .0004);
		
		VisionTarget bottomLeft = new VisionTarget(500, 330, 100, 100, 125, .0006);
		VisionTarget bottomRight = new VisionTarget(920, 500, 100, 100, 128, .0235);
		
		System.out.println("TOP LEFT maps from (" + topLeft.getRawX() + "," + topLeft.getRawY() + ") to "
				+ "(" + topLeft.getMappedX() + "," + topLeft.getMappedY() + ").");
		System.out.println("TOP RIGHT maps from (" + topRight.getRawX() + "," + topRight.getRawY() + ") to "
				+ "(" + topRight.getMappedX() + "," + topRight.getMappedY() + ").");
		System.out.println("BOTTOM LEFT maps from (" + bottomLeft.getRawX() + "," + bottomLeft.getRawY() + ") to "
				+ "(" + bottomLeft.getMappedX() + "," + bottomLeft.getMappedY() + ").");
		System.out.println("BOTTOM RIGHT maps from (" + bottomRight.getRawX() + "," + bottomRight.getRawY() + ") to "
				+ "(" + bottomRight.getMappedX() + "," + bottomRight.getMappedY() + ").");
	}
	
	/**
	 * Automatically returns the vertical angle of the target (perpendicular to the plane of the field), based on values in the NetworkTable
	 * @return double angleVertical. Down - negative; up - positive
	 * We should *NEVER* get a negative value, because that means the robot (or camera) is above the goal, which
	 * means it's probably flying.
	 */
	public double getYAngleToTarget() {
		
		VisionTarget t = this.getBestTarget();
		
		if (t == null) {
			System.out.println("ERR: No target detected. Returning -9999");
			return -9999;
		}
		
		double objectPositionY = t.getMappedY();
		
		double[] FOVs = this.diagonalFieldOfViewToXYFieldOfView();
		
		/* Take the pixel offsets of the object from the center of the image
		 * Multiply by half of the FOV per pixel on that axis because we have FOV/2 field of view
		 * in each direction on that axis.
		 */
		double angleOffsetY = objectPositionY  * (FOVs[0]/this.cameraPixelsX);
		
		return angleOffsetY + this.cameraOffsetAngleY;
	}
	
	/**
	 * @return IN THEORY, the true distance from the shooter to the target
	 */
	public double getRealDistanceToTarget() {
		// Should be as simple as this since these distances are in parallel directions
		return this.getDistanceToTarget() + this.cameraOffsetDistanceY;
	}
	
	/**
	 * @return VisionTarget instance of the largest goal detected by GRIP
	 */
	public VisionTarget getBestTarget() {
		ArrayList<VisionTarget> targets = new ArrayList<VisionTarget>();
		
		if (this.tableConnected()) {
			double[] coordsX = this.getValArray("centerY");
			
			// make sure we have a target first
			if (coordsX.length < 1) {
				return null;
			}
	
			// hope we get all these values before GRIP ticks again
			// and targets potentially disappear, which would cause an out
			// of bounds issue.
			double[] coordsY = this.getValArray("centerX");
			
			double[] heights = this.getValArray("width");
			double[] widths = this.getValArray("height");
			
			double[] areas = this.getValArray("area");
			double[] solidity = this.getValArray("solidity");
			
			for (int i = 0; i < (coordsX.length); i++) {
				targets.add(new VisionTarget(coordsX[i], coordsY[i], heights[i], widths[i], areas[i], solidity[i]));
			}
			
			// sort by area first using Comparable interface spec (will sort by area, in this case)
			targets.sort(null);
			
			return targets.get(0);
		} else {
			System.out.println(unconnectedError);
			return null;
		}
	}
	
    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }
}