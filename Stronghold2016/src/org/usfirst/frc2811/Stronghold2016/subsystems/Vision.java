// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc2811.Stronghold2016.subsystems;

import java.io.IOException;

import com.ni.vision.NIVision;
import com.ni.vision.NIVision.Image;

import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.networktables.NetworkTable;

public class Vision extends Subsystem {
	
	/**
	 * NetworkTables handle to the NetworkTable GRIP will push values to
	 */
	private NetworkTable grip;
	
	/**
	 * Name of the NetworkTable that GRIP will push values to
	 */
	private String tableName;
	
	/**
	 * Default/fallback/failure value for multi-number NetworkTables data types
	 */
	private double[] defaultValue = new double[0];
	
	/**
	 * Default/fallback/failure value for single number NetworkTables data types
	 */
	private double defaultSingleValue = 0;
	
	/**
	 * Error message to display if the GRIP NetworkTable does not exist or cannot be connected to
	 */
	private String unconnectedError = "VISION: Error -> NT not connected!";
	
	/**
	 * Distance left or right from the shooter to the camera
	 * Camera right of shooter: Positive value
	 * Camera left of shooter: Negative value 
	 */
	private double cameraOffsetDistanceX = 0;
	
	/**
	 * Distance up or down from the shooter to the camera
	 * Camera above shooter: Positive value
	 * Camera below shooter: Negative value
	 */
	private double cameraOffsetDistanceY = 0;
	
	/**
	 * Diagonal field of view of the camera
	 */
	private double diagonalFieldOfView = 0;
	
	/**
	 * Number of horizontal pixels provided by the camera
	 */
	private double cameraPixelsX = 0;
	
	/**
	 * Number of vertical pixels provided by the camera
	 */
	private double cameraPixelsY = 0;
	
	
	/**
	 * Initialize the Vision subsystem
	 * 
	 * @param networkTableName Network Table name for GRIP to post values to
	 * @param offsetX Left/Right offset of camera, in feet, relative to shooter. left: < 0; right > 0
	 * @param offsetY Up/Down offset of camera, in feet, relative to shooter. down: < 0; up > 0
	 * @param diagonalFieldOfView The diagonal field of view (in degrees) of the camera used by the subsystem
	 * @param cameraPixelsX Number of horizontal pixels provided by the camera used by the subsystem
	 * @param cameraPixelsY Number of vertical pixels provided by the camera used by the subsystem
	 */
	public Vision(String networkTableName,
				  double offsetX, double offsetY, // Physical attributes of the camera
				  double diagonalFieldOfView, int cameraPixelsX, int cameraPixelsY){ // Technical attributes of camera
		this.tableName = networkTableName;
		
		this.cameraOffsetDistanceX = offsetX;
		this.cameraOffsetDistanceY = offsetY;
		
		this.diagonalFieldOfView = diagonalFieldOfView;
		this.cameraPixelsX = cameraPixelsX;
		this.cameraPixelsY = cameraPixelsY;

		//this.cameraInit();

		// These may need to be reversed?
		this.netTableInit();
		this.gripInit();
	}

	// TODO: breaks
	/**
	 * Initialize the camera for the NIVision framework. Primarily used to send images to the DS/SmartDashboard.
	 * Do not run this unless you want to break GRIP, or unless you've fixed <b><i><u>the problem</u></i></b>.
	 */
	public void cameraInit() {
		Image frame;
		int session;
		frame = NIVision.imaqCreateImage(NIVision.ImageType.IMAGE_RGB, 0);
    	session = NIVision.IMAQdxOpenCamera("cam0",
                NIVision.IMAQdxCameraControlMode.CameraControlModeController);
        NIVision.IMAQdxConfigureGrab(session);
	}
	
	/**
	 * Initialize the tableName NetworkTable for vision values
	 */
	public void netTableInit() {
		// getTable initializes tableName when it doesn't already exist
		grip = NetworkTable.getTable(tableName);
		
		System.out.println("VISION: NT Connected: " + grip.isConnected());
	}
	
	/**
	 * Start the GRIP process
	 */
	public void gripInit() { //initializes grip on the roborio
		try {
			//				 prep to execute a new java program (GRIP) from the GRIP jarfile		
			new ProcessBuilder("/usr/local/frc/JRE/bin/java", "-jar", "/home/lvuser/grip.jar",
					// with our GRIP project file, the parent IO stream, and finally start the process
    				"/home/lvuser/project.grip").inheritIO().start();
    		//TODO add print statement to make sure things work right
    		
    	} catch (IOException e) {
    		// The GRIP jarfile is not there, our project file is not there, or something else went horribly wrong.
    		e.printStackTrace();
    	}
	}
	
	/**
	 * @return If the handle to GRIP's NetworkTable is valid and functioning
	 */
	private boolean tableConnected() {
		if(grip.isConnected()) {
			return true;
		}
		return false;
	}
	
	/**
	 * @param tableKey The key on the GRIP NetworkTable to get values from
	 * @return Values in tableKey on the GRIP NetworkTable
	 */
	public double[] getValArray(String tableKey){ //can be used to get number array values such as area
		if (this.tableConnected()) {
			return grip.getNumberArray(tableKey, defaultValue);
		} else {
			System.out.println(unconnectedError);
			return defaultValue;
		}
	}
	
	/**
	 * @return Coordinate of the center of the target
	 */
	public double[] getTargetCoordinate() { //returns (x, y) coordinate 
		if(this.tableConnected()) {
			double getX = grip.getNumber("centerX", defaultSingleValue);
			double getY = grip.getNumber("centerY", defaultSingleValue);
			double[] centerXY = {getX, getY};
			return centerXY;
		} else {
			System.out.println(unconnectedError);
			return defaultValue;
		}
	}
	
	/**
	 * @return Horizontal distance to target
	 */
	public double getDistanceToTarget() {
		double angleToTarget = this.getYAngleToTarget();
		
		//TODO: Figure out camera height off the ground. The calculation is affected by this.
		/* NOTE: This is NOT the same as cameraOffsetDistanceY!!! cameraOffsetDistanceY is used to account
		 * for the difference in position between the shooter and the camera, and ignores the positioning
		 * off of the ground because that doesn't affect the other trig that will do that stuff.
		 */
		double cameraHeight = .75; // 9 inches = .75 feet
		
		// goal center height is 8'1". Subtract the camera height to get the height difference (opp in trig)
		// this height is the distance from the ground to the middle of the target/goal
		double goalHeight = 8.0 + (double)1/12 - cameraHeight;
		
		/*  tan(angle) = goalHeight / distanceX
		    
		    distanceX*tan(angle) = goalHeight
		    
		    distanceX = goalHeight / tan(angle)
	    */
		double distanceX = goalHeight / Math.tan(Math.toRadians(angleToTarget));
		
		return distanceX;
	}
	/**
	 * Overload of isOnTarget(double angleTolerance). Passes default value of 3 as angleTolerance.
	 * @return Whether or not the robot/shooter is aligned with the target, +- 3 degrees.
	 */
	public boolean isOnTarget() {
		return isOnTarget(3);
	}
	
	/**
	 * @param angleTolerance Tolerance, in degrees, within which the actual angle can differ from "perfect" alignment
	 * @return Whether or not the robot/shooter is aligned with the target, +- angleTolerance degrees.
	 */
	public boolean isOnTarget(double angleTolerance) {
		double horizontalAngleOffset = this.getXAngleToTarget();
		
		/* Return true if the robot needs to turn less than angleTolerance degrees to be aligned
		 * with the target
		 */
		return Math.abs(horizontalAngleOffset) <= angleTolerance;
	}
	
	/**
	 * Break down the diagonal field of view of the camera into horizontal FOV and vertical FOV
	 * @return an array containing {horizontal fov, vertical fov} in degrees
	 */
	private double[] diagonalFieldOfViewToXYFieldOfView(){
		
		// just an angle for the trig stuff... lower left acute angle for a 720p camera
		double angle = Math.toDegrees(Math.atan((double)this.cameraPixelsY/this.cameraPixelsX));
		
		// You can decompose a diagonal FOV with just basic trig
		double fovX = this.diagonalFieldOfView * Math.cos(Math.toRadians(angle));
		double fovY = this.diagonalFieldOfView * Math.sin(Math.toRadians(angle));

		double[] fovArray = {fovX, fovY};
		
		return fovArray;
	}
	
	/**
	 * Automatically returns the horizontal angle of the target (parallel to the plane of the field), based on values in the NetworkTable
	 * @return double angleHorizontal. Left - negative; Right - positive
	 */
	public double getXAngleToTarget() {
		
		double[] objectPosition = this.getTargetCoordinate();
		
		double[] FOVs = this.diagonalFieldOfViewToXYFieldOfView();
		
		/* Take the pixel offsets of the object from the center of the image
		 * Multiply by half of the FOV per pixel on that axis because we have FOV/2 field of view
		 * in each direction on that axis.
		 */
		double angleOffsetX = (objectPosition[0] - (this.cameraPixelsX/2.0)) * (FOVs[0]/2/this.cameraPixelsX);
				
		return angleOffsetX;
	}
	
	/**
	 * Automatically returns the vertical angle of the target (perpendicular to the plane of the field), based on values in the NetworkTable
	 * @return double angleVertical. Down - negative; up - positive
	 * We should *NEVER* get a negative value, because that means the robot (or camera) is above the goal, which
	 * means it's probably flying.
	 */
	public double getYAngleToTarget() {
		
		double[] objectPosition = this.getTargetCoordinate();
		
		double[] FOVs = this.diagonalFieldOfViewToXYFieldOfView();
		
		/* Take the pixel offsets of the object from the center of the image
		 * Multiply by half of the FOV per pixel on that axis because we have FOV/2 field of view
		 * in each direction on that axis.
		 */
		double angleOffsetY = (objectPosition[1] - (this.cameraPixelsY/2.0)) * (FOVs[1]/2/this.cameraPixelsY);
		
		return angleOffsetY;
	}
	
    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }
}