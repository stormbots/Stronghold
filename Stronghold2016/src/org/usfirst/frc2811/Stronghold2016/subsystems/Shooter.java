// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc2811.Stronghold2016.subsystems;

import org.usfirst.frc2811.Stronghold2016.Robot;

import edu.wpi.first.wpilibj.CANTalon;
import edu.wpi.first.wpilibj.command.Subsystem;

/**
 * Shooter tops out with getEncVelocity() of  ~53000. 
 * Tested speed for shooting a high goal from the batter is rate of 38176 ticks 

 */
public class Shooter extends Subsystem {
	  CANTalon motorRight;
	  CANTalon motorLeftFollower;
	  
	  public double maxCurrent=0;

 
    // Initialize your subsystem here
    public Shooter() {
        motorRight = new CANTalon(5); // Talon Address 5 on the robot
        motorRight.reverseOutput(true); //WORKS! :D
        motorRight.reset();

        //MotorLeft has the easy task of just doing what 5 is told. 
        motorLeftFollower = new CANTalon(4); // Talon Address 5 on the robot
        motorLeftFollower.changeControlMode(CANTalon.TalonControlMode.Follower);
        motorLeftFollower.set(5);
        motorLeftFollower.reverseOutput(true);
        motorLeftFollower.enableBrakeMode(false);
        
        
        motorRight.setFeedbackDevice(CANTalon.FeedbackDevice.CtreMagEncoder_Relative);
        motorRight.reverseSensor(true);
        motorRight.setEncPosition(0);

        
        //TODO: I'm not sure what the actual PID value is for this motor. 
        // It's very likely the last value written to it from some other code, or 
        // a default value. Write that down and save it in the configuration here. 
        
        //Could potentially be the values on the robot, but this is likely not it. 
        /* uncomment for current mode
        motor.setPID(1.0, 0.0, 0.0);
        motor.changeControlMode(CANTalon.TalonControlMode.Current);
        motor.set(0);
        //*/
        //rate controlled mode
        //motor.setPID(0.0, 0.0, 0.0);
        //motor.setF(1);
        motorRight.changeControlMode(CANTalon.TalonControlMode.Speed);

        
        //Every control mode needs these
        motorRight.enable();
        motorRight.enableBrakeMode(false);
        motorRight.set(0);
        //Remove the ability of the motor to reverse
        //This keeps it from fighting itself if the PID oscillates
        // and forces it to go in the forward direction.
        motorRight.configPeakOutputVoltage(0,-12);
        motorRight.clearStickyFaults();
        
    }
    
    
    public void initDefaultCommand() {
    }
    
    public double maxCurrentDraw(){
    	if(Robot.powerPanel.getCurrent(12)>maxCurrent){
    		maxCurrent = Robot.powerPanel.getCurrent(12);
    	} else if (Robot.powerPanel.getCurrent(13)>maxCurrent){
    		maxCurrent = Robot.powerPanel.getCurrent(13);
    	}
    	return maxCurrent;
    }
    
    public double distanceToFPS(double distance){
    	double g = -32.174;//32 feet per second
    	double y = 7.7;//TODO double check target height
    	double x = distance;// FIXME get the distance to goal in x direction from camera in feet
    	if(distance<5){
    		System.out.println("Distance too short! Stopping");
    		return 0;
    	}

    	///*
    	double theta = Math.toRadians(62.5);//TODO remeasure on physical robot
		System.out.println("Theta radians" +Math.tan(theta));

    	double radicand=(2*(y-Math.tan(theta)*x)/g);
		System.out.println("Radicand: " +radicand);
		
    	double time = Math.sqrt(radicand);
    	System.out.println("time: " +time);
		
    	double feetPerSecond = (x/time)/Math.cos(theta);
    	System.out.println("feet per second: " +feetPerSecond);
    	
		return feetPerSecond;
		//*/
    	
    	
    	/*
    	Right Monstrosity goes here
    	
    					x
    	   ______________________________
    	    ________________________
    	   /	2(y-xtan(theta))
    	  /____________________
    	 /			gravity
    	V______________________________
    					cos(theta)
    	*/
    	
    	//DO math to convert distance to velocity
    	
    }
    /**
     * This Converts the expected velocity that is required to shoot the ball to the goal x feet away. It goes from 
     * velocity divided by wheel radius, then multiplied by 4096 ticks times 100 per revolution, then divided by 1000
     * @param feetPerSecond
     * @return Ticks Per 10 Milliseconds
     */
    private double FPSToTicksPer10MS(double feetPerSecond){
    	double wheelRadius=1/6.0;//TODO Change this value to correct wheel radius
    	double TicksPer50MS = (feetPerSecond*4096*100)/(wheelRadius*1000.0);
    	
    	System.out.println("tickRate: " +TicksPer50MS);

    	//Get Velocity from shooter
    	//TODO do math to convert velocity from feet per second to ticks per second
    	return TicksPer50MS;
    }
    
    /*
 private void setShooterRateManually(double tickRotation){
	 System.out.println("Manual write! "+tickRotation+" ticks per rate");
	 shooterWheelPID.setMotorVelocity(tickRotation);
 }
 */
 
 public void setShooterDistance(double distanceToTarget){
	//convert distance to required FPS
 	//convert FPS to required encoder ticks per second
	double calculatedoutput = FPSToTicksPer10MS(distanceToFPS(distanceToTarget));

	 System.out.println("Feet Per second:"+ distanceToFPS(distanceToTarget));
	 //System.out.printlin("" + )
	 System.out.println("Calculated output:"+ calculatedoutput);

	 //Plan for fudging the numbers
	 double fudgesquared=0;
	 double fudgelinear=0;
	 double fudgeconstant=0;
	 
	 double output=calculatedoutput + (fudgesquared*fudgesquared) + (fudgelinear) +(fudgeconstant);
	 
	 //write to motor
	 setVelocityRaw(output);
	 //DONE!?
    }
 	
    
    
    
	 public void setVelocityRaw(double rateInTicks) {
			motorRight.set(rateInTicks);
	 }

	 public void setWheelRPM(double rateRPM_NotImplimented) {
    	// TODO add code that maps this correctly
		// https://www.ctr-electronics.com/Talon%20SRX%20Software%20Reference%20Manual.pdf
		// According to the manual, the units for CANTalon.set() with this sensor should be RPM.
		 //
		 //However, it's NOT correct according to the gear ratio on our robot, which will 
		 //scale it down due to the input/output shaft ratios.
		 // This is partially taken care if on the distanceToFPS function
		 
	 	//setVelocityRaw(rateRPM);
	 }
	 
	 public void setVelocityToShootFromBatter() {
		 //tested successful velocity 
		 // 53000 is the speed the wheel was moving when we made a goal with
		 // the competition bot from the batter
		 setVelocityRaw(53000*.3);
		 System.out.println("Shooter Velocity" + motorRight.get());
		 }

	 public boolean isAtTargetVelocity() {
		 return Math.abs(motorRight.getClosedLoopError())<2650;
		 }
        
	protected double map( double input, double maximum, double minimum, double outputMax, double outputMin){
    	double output = (input/(maximum-minimum)-minimum/(maximum-minimum))*(outputMax-outputMin)+outputMin;
    	if (output==Double.NaN){
    		output=minimum;//Shouldn't happen unless we divide by zero somewhere
    		}
    	return output; 
    }
     
}
